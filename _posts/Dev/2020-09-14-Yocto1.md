---
title:  "[Reapberrypi] 01. Build Linux image using Yocto"
excerpt: "Raspberry Pi를 깨우기 위한 Yocto OS 빌드 과정 및 처음 부팅 후 설정에 대해 다룹니다."

categories:
  - Dev
tags:
  - Yocto
  - Raspberry Pi
---

본 문서는 아래 블로그 글과 몇번의 삽질을 기반으로 작성되었습니다.

- [https://www.yoctoproject.org/docs/1.8/ref-manual/ref-manual.html#ref-structure](https://www.yoctoproject.org/docs/1.8/ref-manual/ref-manual.html#ref-structure)
- [https://js94.tistory.com/entry/라즈베리파이3Raspberry-Pi3에-Yocto-Project-설치](https://js94.tistory.com/entry/%EB%9D%BC%EC%A6%88%EB%B2%A0%EB%A6%AC%ED%8C%8C%EC%9D%B43Raspberry-Pi3%EC%97%90-Yocto-Project-%EC%84%A4%EC%B9%98)
- [https://gachiemchiep.github.io/cheatsheet/build_image_rpi3_yocto/](https://gachiemchiep.github.io/cheatsheet/build_image_rpi3_yocto/)
- [https://blog.naver.com/jswcomkr/221456104994](https://blog.naver.com/jswcomkr/221456104994)
- [https://blog.naver.com/jjong_w/221215120702](https://blog.naver.com/jjong_w/221215120702)
- [https://jumpnowtek.com/rpi/Raspberry-Pi-Systems-with-Yocto.html](https://jumpnowtek.com/rpi/Raspberry-Pi-Systems-with-Yocto.html))


## 시작하며...

 리눅스라는 OS를 하루이틀 쓴 것은 아니지만 아직도 낮설다. 특히 embedded level로 내려가면 더욱 그렇다.  부팅은 어떤 과정을 거쳐 진행되며, 각종 device는 어떤 원리로 동작되며, 간단한 함수로 사용하는 카메라는 어떻게 인식되는지 궁금한 것 투성이다.  

  BSP 담당자에게 어찌 공부하면 되냐고 물어보니 일단 Raspberry Pi에 Yocto 올려서 이것저것 해보라고 한다. 한번만 해보면 된다고 하기에 일단 그렇게 해보기로 했다. 먼저 Raspberry Pi에 Linux를 올려서 부팅을 해야 한다.

### Document History

- Rev. 1: Init.
- Rev. 2: yocro version 변경 (pyro → dunfell)

## 1. Build 환경

### a. 빌드 준비

- VirtualBox에서 동작하는 Ubuntu 16.04에서 진행.
- Dependency 설치

	```bash
	sudo apt-get install gawk wget git-core diffstat unzip texinfo gcc-multilib build-essential chrpath socat cpio python python3 python3-pip python3-pexpect xz-utils debianutils iputils-ping libsdl1.2-dev xterm bmap-tools
	```

- Yocto pyro 버전은 gcc 6이상에서 빌드된다고 하니 gcc도 upgrade 해준다.

	```bash
	sudo add-apt-repository ppa:ubuntu-toolchain-r/test
	sudo apt-get update
	sudo apt-get install gcc-6 g++-6

	sudo update-alternatives --install /usr/bin/gcc gcc /usr/bin/gcc-6 60
	sudo update-alternatives --install /usr/bin/g++ g++ /usr/bin/g++-6 60
	```

### b. 해봤는데 안되는 것

- WSL(windows subsystem for Linux)1에서는 안됨 
- openembedded가 WSL1을 지원 안한다.. WSL2는 가능하다고 한다.
- clone한 poky 폴더가 home 폴더에 있어야 함.
- Ubuntu 16.04에서 gcc 6.5 설치된 환경에서 성공
- Laptop의 내장 SD card 리더기는 virtualbox에서 인식이 안되므로 usb 타입의 리더기가 필요. 

## 2. Yocto build (Host System)

- Yocto Project의 Release 정보에서 ([Link](https://wiki.yoctoproject.org/wiki/Releases)) 원하는 버전을 선택한다. 
본 글은  dunfell 버전 기준으로 설명한다

### a. poky 및 Reapberrypi bitbake recipe download

- Poky project repository를 폴더에 clone 한다.

    ```bash
    # poky-dunfell 폴더에 clone
    git clone -b dunfell git://git.yoctoproject.org/poky.git poky-dunfell
    ```

- Raspberry Pi 구동에 필요한 recipe를 clone한다.

    ```bash
    cd poky-dunfell

    git clone -b dunfell git://git.yoctoproject.org/meta-raspberrypi
    git clone -b dunfell git://git.openembedded.org/meta-openembedded
    git clone -b dunfell https://github.com/meta-qt5/meta-qt5
    git clone -b dunfell git://git.yoctoproject.org/meta-security.git
    ```

- [Option] Python 용 TensorFlow Lite Interpreter를 추가하려면 다음 recipe도 clone 한다.

    ```bash
    git clone https://github.com/NobuoTsukamoto/meta-tensorflow-lite.git
    ```

### b. build 환경으로 전환

- 다음 명령어를 실행하여 open-embedded 빌드 환경을 설정한다.

    ```bash
    # source oe-init-build-env {build_name}
    # build라는 폴더를 만들고 빌드환경 설정
    source oe-init-build-env build
    ```

### c. configure file 수정

- bblayer.conf 수정

    ```bash
    vi conf/bblayers.conf
    ```

    : raspberrypi 및 openembedded meta file 추가.

    ```bash
    # POKY_BBLAYERS_CONF_VERSION is increased each time build/conf/bblayers.conf
    # changes incompatibly
    POKY_BBLAYERS_CONF_VERSION = "2"

    BBPATH = "${TOPDIR}"
    BBFILES ?= ""

    BBLAYERS ?= " \
      {HOME PATH}/poky/meta \
      {HOME PATH}/poky/meta-poky \
    	{HOME PATH}/poky/meta-openembedded/meta-oe \
      {HOME PATH}/poky/meta-openembedded/meta-multimedia \
      {HOME PATH}/poky/meta-openembedded/meta-networking \
      {HOME PATH}/poky/meta-openembedded/meta-perl \
      {HOME PATH}/poky/meta-openembedded/meta-python \
      {HOME PATH}/poky/meta-qt5 \
      {HOME PATH}/poky/meta-raspberrypi \
      {HOME PATH}/poky/meta-security \
    	{HOME PATH}/poky/meta-tensorflow-lite \
      "
    ```

- conf/local.conf 수정하여 Raspberry Pi환경에 맞게 설정한다.

    ```bash
    vi conf/local.conf
    ```

    : Raspberry Pi와 관련있는 option은 다음과 같다. (reference: [link](https://meta-raspberrypi.readthedocs.io/_/downloads/en/zeus/pdf/)) 

    ```
    ***MACHINE***: target system. Raspberrypi의 모델 맞춰 설정한다.
              → 64bit로 빌드할 경우 "{model명}-64"로 지정
    ***IMAGE_FSTYPES***: 생성할 image의 filesystem 설정 (default: *.sdimg)
    ***IMAGE_ROOTFS_EXTRA_SPACE***: rootfs의 여유공간을 설정

    ***VIDEO_CAMERA***: Raspberry Pi camera를 enable 시킴 (default 0 (OFF))

    ***BB_NUMBER_THREADS***: recipe를 빌드할 때 사용할 core 수 지정
    ***PARALLEL_MAKE***: make 수행 시 사용할 core 수 지정 
    ```

    ```bash
    ***CORE_IMAGE_EXTRA_INSTALL***
    :core-image class에 정의된 package 중 빌드 시 추가할 package를 지정
    :OpenCV를 추가하는 경우 다음과 같이 추가한다. 
    # NOTE: OPENCV_contrib is already include inside opencv package
    # add libopencv-XXX to insert new module
     →CORE_IMAGE_EXTRA_INSTALL += "opencv \
                                libopencv-core-dev \
                                libopencv-highgui-dev \
                                libopencv-imgproc-dev \ 
                                libopencv-objdetect-dev \
                                libopencv-ml-dev \
                                opencv-apps \
                                opencv-dev \
                                libopencv-xphoto \
                                opencv-dev "

    ***IMAGE_INSTALL_append***
    :image에 추가할 package를 지정 (
    :반드시 첫번째 package를 기입시 space를 추가한다.)
    :python 사용
     → IMAGE_INSTALL_append = " python3 python3-pip python3-numpy python3-pillow "
    :Tensorflow-Lite interpreter 사용
     → IMAGE_INSTALL_append = " python3-tensorflow-lite"
    :OpenCV-python
     → IMAGE_INSTALL_append = " python3-opencv"
    :C/C++
     → IMAGE_INSTALL_append = " libstdc++"

    ```

    : Raspberry Pi용 64-bit Yocto Linux 빌드 예제는 다음과 같다.   → 

    ```bash
    # conf/local.conf
    MACHINE ??= "raspberrypi3-64"

    IMAGE_FSTYPES = "wic.bz2"

    VIDEO_CAMERA = "1" # camera enable

    BB_NUMBER_THREADS = "3" # build 환경의 thread 수를 적음
    PARALLEL_MAKE = "-j 3"

    DISTRO_FEATURES_remove = "ipv6"
    IMAGE_ROOTFS_EXTRA_SPACE = "4194304" # rootfs의 여유공간을 4Gb로 설정

    IMAGE_INSTALL_append = " python3 python3-pip python3-numpy python3-pillow \
    												python3-tensorflow-lite python3-opencv \
    												libstdc++ \ 
    												linux-firmware-bcm43430 bluez5 i2c-tools bridge-utils hostapd dhcp-server iptables wpa-supplicant"
    ```

### d. bitbake 실행 

- bitbake는 poky 빌드 시스템의 task scheduler로 meta-data를 parsing하고 task로 만들어 관리한다.
- meta-raspberrypi에 정의되어 있는 recipe (package 빌드를 위한 명령어 세트)를 bitbake를 이용하여 빌드한다.

	```bash
	bitbake rpi-hwup-image
	**bitbake rpi-basic-image** # ssh 이용시 선택
	bitbake rpi-test-image
	```

	![yocto_result](https://jerogar.github.io/img/Yocto1/yocto2.png)

## 3. SD card에 복사 (Host System)

- build 완료되면 다음 경로에 SD card에 온보딩 할 수 있는 image 파일이 생성된다.

	```
	Path: {poky 경로}/{build 경로}/tmp/deploy/images/{MACHINE}"
	image 파일 명: {recipe}-{MACHINE}.wic.bz2

	e.g.
	poky 경로: /home/name/poky
	build 경로: build/
	MACHINE: raspberrypi3-64
	recipe: rpi-basic-image
	-> /home/name/poky/build/tmp/deploy/images/raspberrypi3-64
	   rpi-basic-image-raspberrypi3-64.wic.bz2
	```

- bmaptool을 이용하여 sdcard로 복사한다.

	```bash
	#sudo bmaptool copy {image_file_path} /dev/{SD card}
	# SD card 위치 "/dev/{SD card}"는 lsblk 명령어로 찾을 수 있다
	#e.g.
	sudo bmaptool copy rpi-basic-image-raspberrypi3-64.wic.bz2 /dev/sdb
	```

- 만약 local.conf에 별도로 image file system을 지정하지 않은 경우 "*.sdimg"* 파일이 생성되는데, 이 경우 dd 명령어를 이용하여 SD card에 복사한다.

	```bash
	#sudo dd if={image_file_path} of={/dev/{SD card}}
	#e.g.
	sudo dd if=rpi-basic-image-raspberrypi3-64.rpi-sdimg of=/dev/sdb
	```

## 4. Toolchain 생성 (Host System)

- Host PC에서 Raspberry pi에서 동작하는 실행 파일의 빌드를 위해 cross-compile 환경 설정 파일을 생성한다.

	```bash
	source oe-init-build-env {build_name}
	cd {build_name}
	bitbake meta-toolchain
	bitbake meta-ide-support
	```

- 컴파일이 완료되면 다음 경로에 cross-compile 환경설정을 위한 shell 파일을 확인할 수 있다

	```
	Path: {poky 경로}/{build 경로}/tmp/deploy/sdk/"
	image 파일 명: poky-glibc-x86_64-meta-toolchain-{archtecture명}-{MACHINE}-toolchain-{version명}.sh

	e.g.
	poky/build/tmp/deploys/sdk/
	poky-glibc-x86_64-meta-toolchain-aarch64-raspberrypi3-64-toolchain-3.1.7.sh*
	```

## 5. 부팅 및 network 설정

- 복사한 image가 포함된 SD card를 Raspberry Pi의 메모리 슬롯에 삽입하고 전원을 인가하면 부팅이 시작된다. (monitor 연결 필요)
- 정상적으로 부팅이 안되는 경우 LED 상태에 따라 상태를 진단할 수 있다. ([https://wikidocs.net/64943](https://wikidocs.net/64943))
- 별도 설정이 없는 경우 ID: root 로 설정되어 있다.
- Raspberry Pi 3B+ recipe의 경우 무선 LAN driver에 문제가 있어 build 시 추가 설정이 필요하지만 동작하지 않아 유선 LAN으로 host PC와 연결 후 SSH로 연결했다.
(무선 LAN 관련 이슈 참고자료: [link](https://raspinterest.wordpress.com/2017/02/28/configure-wlan0-and-bluetooth-in-yocto-raspberry-pi-3/))

### a. 고정 IP 설정 (Raspberry Pi)

- 부팅 후 다음과 같이 고정 IP를 설정한다.

	```bash
	vi /etc/network/interfaces
	```

- 본 문서에서는 IP를 192.158.137.6로 설정했다.

    ![yocto_result](https://jerogar.github.io/img/Yocto1/yocto3.png)

- 재부팅 후 설정을 적용한다.

	```bash
	reboot
	```

### b. LAN cable로 PC와 연결하고 SSH 연결 (Host PC)

- Raspberry Pi와 Host PC를 LAN cable로 연결한 후 해당 network adapter의 IP를 다음과 같이 임의로 설정한다. (윈도우 설정 참고: [https://naudhizb.tistory.com/307](https://naudhizb.tistory.com/307))

	![yocto_result](https://jerogar.github.io/img/Yocto1/yocto4.png)

- ssh 접속한다.  Putty, MobaXTerm과 같은 terminal 프로그램을 이용할수도 있다.

    ```bash
    # [in Host PC]

    # ssh {ID}@{Raspberry IP IP}
    # e.g.
    ssh root@192.168.137.6
    ```

- scp 명령어를 이용하여 파일을 전송할 수 있다.

    ```bash
    # [in Host PC]

    # scp <file_name> <id>@<address>:<path>
    # e.g. testapp 을 192.168.137.6의 ip를 가지는 Raspberry Pi의 /home/root에 복사
    scp testapp root@192.168.137.6:/home/root

    # e.g. 192.168.137.6의 ip를 가지는 Raspberry Pi의 /home/root/testapp 파일을 
    # Host PC의 /home/name 복사
    scp root@192.168.137.6:/home/root/testapp /home/name
    ```
