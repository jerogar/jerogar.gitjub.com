---
title:  "[Reapberrypi] 03. ARM NEON Intrinsic"
excerpt: "ARM AP에서 사용할 수 있는 SIMD 명령어를 사용해 봅시다."

categories:
  - Dev
tags:
  - Yocto
  - Raspberry Pi
  - NEON
---

## Reference

- [https://developer.arm.com/documentation/102159/latest/](https://developer.arm.com/documentation/102159/latest/)
- [https://developer.arm.com/documentation/102525/0100](https://developer.arm.com/documentation/102525/0100)
- [https://minimonk.tistory.com/5509?category=594651](https://minimonk.tistory.com/5509?category=594651)

## 1. ARM Neon intrinsic

- NEON은 ARM processor에서 제공하는 64/128bit SIMD (Single Instruction Multiple Data)로, Raspberry Pi 3에 적용된 Cortex-A53 processor의 경우 다음과 같은 co-processor 구조로 되어있다.

![A53](https://jerogar.github.io/img/Yocto3/CortexA53.png)

- [NNPACK](https://github.com/Maratyszcza/NNPACK), 및 TensorFlow Lite에 적용된 [XNNPACK](https://github.com/google/XNNPACK)의 library에서 ARM에 최적화된 연산을 위해  NEON을 사용한다.
- [https://developer.arm.com/architectures/instruction-sets/simd-isas/neon](https://developer.arm.com/architectures/instruction-sets/simd-isas/neon)

## 2. Compile 과정에서 최적화

Reference: [https://gcc.gnu.org/projects/tree-ssa/vectorization.html](https://gcc.gnu.org/projects/tree-ssa/vectorization.html)

- 다음과 같이 반복 수행되는 루틴의 경우 compile 최적화를 level 2 이상으로 설정하고 "-ftree-vectorize" 옵션를 추가하면 자동으로 NEON이 적용되어 최적화 된다.

    ```bash
    armgcc -mcpu=cortex-a53, -O3 -Otime --vectorize -c vectorized.c

    # yocto 환경변수 setting 되어있는 경우
    ${CXX} -mcpu=cortex-a53 -O3 --vectorize -c vectorized.c
    ```

    아래 코드는 __restricted로 변수 pa, pb가 중복되지 않고, n의 4의 배수로 for look가 수행된다. 이런 경우 vectorizing하여 최적화가 가능하다. 

    ```cpp
    void add_ints(int* __restrict pa, int* __restrict pb, unsigned int n, int x)
    {
    	for(unsigned int i =0; i <(n & ~3); i++)
    	{
    		pa[i] = pb[i] + x;
    	}
    }
    ```

- 다음과 같이 compiler 옵션을 변경하여 fpu 및 NEON 관련 설정을 변경할 수 있다.
    - [https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html](https://gcc.gnu.org/onlinedocs/gcc/ARM-Options.html)
    - [https://pinocc.tistory.com/127](https://pinocc.tistory.com/127)

    ```
    **-mfpu=name**
     floating-point HW를 지정하는 옵션
      → 'auto', 'vfpv3', 'neon-vfpv4'='neon' 사용 가능 
      → 'auto': 컴파일러가 -mcpu 및 -march의 설정에 따라 선택함.
      → 'neon': NEON 명령어/co-processor 사용. 
               (IEEE 754표준을 완전히 지원하지 않기 때문에 정밀도가 손실될 수 있음.)

    **-mfloat-abi=name**
     코드 내 float point 연산에 대한 호출 방식을 지정 (Application Binary Interface)
      → 'soft': float point연산 시 라이브러리 사용
      → 'softfp' soft 방식에 HW적인 명령어도 허용함.
      → 'hard' : FPU, NEON등 float point 명령어만을 사용하는 호출 규칙 생성. 
                (모든 float-point 연산이 명령어에 의해 이루어지도록 구성되어야 함.)
    ```

    - 단 Raspberry Pi Poky sdk에는 기본값이 floating point 연산 library가 포함되지 않아 다음과 설정하지 않는 경우 compile error가 발생한다.

    ```bash
    -mfpu=neon-vfpv4
    -mfloat-abi=hard
    ```

    - 또한 64 bit로 빌드한 경우 arrch64-poky-linux-g++로 compile하게 되는데, 이는 FPU등 co-processor가 자동으로 적용되어 fpu 및 abi의 옵션이 존재하지 않는다. (reference: [Link1](https://stackoverflow.com/questions/29851128/gcc-arm64-aarch64-unrecognized-command-line-option-mfpu-neon), [Link2](https://gcc.gnu.org/onlinedocs/gcc/AArch64-Options.html#AArch64-Options))

## 2. NEON intrinsic 사용 (C/C++)

- C/C++ compiler를 이용하여 intrinsic 방식으로 NEON, VPF를 사용할 수 있다.
- 컴파일러의 CPU 옵션이 반드시 NEON이 있는 AP로 지정되어야 한다.

    ```bash
    armgcc -mcpu=cortex-a53 intrinsic.c

    # yocto 환경변수 setting 되어있는 경우
    ${CXX} -mcpu=cortex-a53 intrinsic.c
    ```

- ARM_NEON.h에 데이터 타입과 함수 원형이 선언되어 있어 어셈블리 명령 기능을 C 형식의 함수로 사용 가능하다.

    ```cpp
    // Example

    #include <arm_neon.h>

    uint32x4_t double_elements(uint32x4_t input)
    {
    	return(vaddq_u32(input, input));
    }

    // ...
    ```

- NEON 연산을 위한 Data type은 다음과 같은 형식으로 정의되어 있다. 
[https://developer.arm.com/documentation/dui0472/k/Using-NEON-Support/NEON-intrinsics-for-loading-an-N-element-structure](https://developer.arm.com/documentation/dui0472/k/Using-NEON-Support/NEON-intrinsics-for-loading-an-N-element-structure)

    ```cpp
    // <type><size>x<# of lenes>x<lenth of array>_t
    // e.g.
    int16x4x2_t // int형 16bit size의 4개의 lane으로 구성된 element가 2개 존재하는 자료형
    ```

- Data type에 저장된 data를 연산하기 위한 함수는 다음 링크에서 찾아볼 수 있다. 
[https://developer.arm.com/architectures/instruction-sets/intrinsics/](https://developer.arm.com/architectures/instruction-sets/intrinsics/)

    ![Neon_Intrinsic](https://jerogar.github.io/img/Yocto3/EG_NEON_Intrinsic.png)

## 3. Matrix Multiply 예제 (64bit only)

- Matrix Multiply를 무식한 방법으로 구현하는 경우 3단계의 for loop를 사용하게 된다. 이를 NEON을 이용하여 최적화 할 수 있다.
- ARM에서 제공하는 Matrix Multiply 예제는 float point로 구성된 matrix의 곱셈을 NEON을 이용하여 최적화 한다.

    [https://developer.arm.com/documentation/102467/0100/Matrix-multiplication-example](https://developer.arm.com/documentation/102467/0100/Matrix-multiplication-example)

    (1) random하게 생성된 float point matrix를 NEON으로 연산하기 위해 NEON intrinsic의 data type인 float32x4_t에 load 한다. 이때 vld1q_f32() 함수를 사용한다. 

    (2) vfmaq_lane_f32(…) 함수를 이용하여 입력된 2개의 float32x4_t type data를 element 별로 곱하고 누적하여 저장한다. 

    (3) 연산이 완료되면 vst1q_f32(…)를 이용하여 float 형 변수로 변환한다. 

- 이 예제는 aarch64에서만 동작하는 intrinsic을 포함하고 있다.

    ```c
    #include <stdio.h>
    #include <stdint.h>
    #include <stdlib.h>
    #include <stdbool.h>
    #include <math.h>
    #include <time.h>

    #include <arm_neon.h>

    #define BLOCK_SIZE 4

    void matrix_multiply_neon(float32_t  *A, float32_t  *B, float32_t *C, uint32_t n, uint32_t m, uint32_t k);
    void matrix_multiply_4x4_neon(float32_t *A, float32_t *B, float32_t *C);
    void print_matrix(float32_t *M, uint32_t cols, uint32_t rows);
    void matrix_init_rand(float32_t *M, uint32_t numvals);
    void matrix_init(float32_t *M, uint32_t cols, uint32_t rows, float32_t val);
    bool f32comp_noteq(float32_t a, float32_t b);
    bool matrix_comp(float32_t *A, float32_t *B, uint32_t rows, uint32_t cols);

    void matrix_multiply_c(float32_t *A, float32_t *B, float32_t *C, 
    											 uint32_t n, uint32_t m, uint32_t k) 
    {
    	for (int i_idx=0; i_idx<n; i_idx++) 
    	{
    		for (int j_idx=0; j_idx<m; j_idx++) 
    		{
    			C[n*j_idx + i_idx] = 0;
          for (int k_idx=0; k_idx<k; k_idx++) 
    			{
    	      C[n*j_idx + i_idx] += A[n*k_idx + i_idx]*B[k*j_idx + k_idx];
          }
    		}
    	}
    }

    int main() 
    {
            uint32_t n = 2*BLOCK_SIZE; // rows in A
            uint32_t m = 2*BLOCK_SIZE; // cols in B
            uint32_t k = 2*BLOCK_SIZE; // cols in a and rows in b
            

            float32_t A[n*k];
            float32_t B[k*m];
            float32_t C[n*m];
            float32_t D[n*m];
            float32_t E[n*m];
            
            bool c_eq_asm;
            bool c_eq_neon;

            matrix_init_rand(A, n*k);
            matrix_init_rand(B, k*m);
            matrix_init(C, n, m, 0);

            print_matrix(A, k, n);
            print_matrix(B, m, k);
            //print_matrix(C, n, m);
            

    				clock_t startTime = clock();
    			  matrix_multiply_c(A, B, E, n, m, k);
    				clock_t endTime = clock();
    				float res1 = (float)(endTime - startTime)/CLOCKS_PER_SEC;

            printf("C\n");
            print_matrix(E, n, m);
    				printf("Processing Time = %05f [sec]\n", res1);
            printf("===============================\n");

    				startTime = clock();
            matrix_multiply_neon(A, B, D, n, m, k);
    				endTime = clock();
    				res1 = (float)(endTime - startTime)/CLOCKS_PER_SEC;

            printf("Neon\n");
            print_matrix(D, n, m);
            c_eq_neon = matrix_comp(E, D, n, m);
    				printf("Processing Time = %05f [sec]\n", res1);
            printf("Neon equal to C? %d\n", c_eq_neon);

            printf("===============================\n");
    }
    ```

- 다음과 같이 makefile을 작성하고 실행파일을 생성 한다.

    ```makefile
    PWD = $(shell pwd)
    BUILD_DIR = $(PWD)/bin
    SRC_DIR = $(PWD)/src

    TARGET = $(BUILD_DIR)/neon_test
    SRCS = $(shell find . -name *.cpp)
    OBJS = $(SRCS:.cpp=.o)

    # Set CXX Options
    #CXX = CARM
    CARM = aarch64-poky-linux-g++ -mcpu=cortex-a53 -fstack-protector-strong  -D_FORTIFY_SOURCE=2 -Wformat -Wformat-security -Werror=format-security --sysroot=/opt/poky64/3.1.7/sysroots/aarch64-poky-linux
    CXXFLAGS := -Wall -O2 $(EXTRA_CFLAGS) -std=c++1y
    LDFLAGS := $(EXTRA_LDFLAGS) -Wl,--as-needed $(INC_DIR) $(LIB_DIR) $(LIBS)

    $(TARGET) :
    	$(CARM) $(CXXFLAGS) -o $@ $(SRCS) $(LDFLAGS)

    .PHONY : clean debugging

    build:
    	@mkdir -p $(BUILD_DIR)

    clean:
    	rm -f $(TARGET) $(OBJS)

    define SHOW_VARIANCES
    	@echo ========================================================
    	@echo [TARGET]: $(TARGET)
    	@echo [SRCS]:
    	@echo $(SRCS)
    	@echo
    	@echo [OBJS]:
    	@echo $(OBJS)
    	@echo ========================================================
    endef

    debugging:
    	$(SHOW_VARIANCES)
    ```

- 실행해보면 단순히 for loop를 이용한 matrix multiply보다 약 2배 가량 성능 개선이 있음을 알 수 있다.

	![Result_MatMul_example](https://jerogar.github.io/img/Yocto3/MatMul_Result.png)
